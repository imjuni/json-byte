/* eslint-disable no-restricted-syntax */
// path-loc-index.jsonc.ts
import { parseTree, type Node as JsoncNode, type ParseError } from 'jsonc-parser';
import type { Position, Range, JsonLikeKind, PrimitiveLoc, PathLocEntry, PathLocIndex } from './types';

// ---------- line map ----------
export function buildLineStarts(text: string): number[] {
  const starts = [0];
  for (let i = 0; i < text.length; i++) {
    const c = text.charCodeAt(i);
    if (c === 13) {
      // \r
      if (i + 1 < text.length && text.charCodeAt(i + 1) === 10) i++; // \r\n
      starts.push(i + 1);
    } else if (c === 10) {
      // \n
      starts.push(i + 1);
    }
  }
  return starts;
}

export function offsetToLineCol(offset: number, lineStarts: number[]): Position {
  // 가독성을 위해 명시적 floor 사용
  let lo = 0,
    hi = lineStarts.length - 1;
  while (lo <= hi) {
    const mid = Math.floor((lo + hi) / 2);
    const a = lineStarts[mid];
    const b = mid + 1 < lineStarts.length ? lineStarts[mid + 1] : Number.MAX_SAFE_INTEGER;
    if (offset < a) hi = mid - 1;
    else if (offset >= b) lo = mid + 1;
    else return { line: mid + 1, column: offset - a + 1 };
  }
  const last = lineStarts[lineStarts.length - 1];
  return { line: lineStarts.length, column: offset - last + 1 };
}

export function toRange(offset: number, length: number, lineStarts: number[]): Range {
  return {
    start: offsetToLineCol(offset, lineStarts),
    end: offsetToLineCol(offset + length, lineStarts),
    offset,
    length,
  };
}

// ---------- JSONPath 유틸 ----------
function escapeJsonPathKey(key: string): string {
  // 항상 bracket-notation로 안전하게 생성
  return `['${key.replace(/\\/g, '\\\\').replace(/'/g, "\\'")}']`;
}

function childPath(base: string, seg: string | number): string {
  if (typeof seg === 'number') return `${base}[${seg}]`;
  return `${base}${escapeJsonPathKey(seg)}`;
}

// ---------- kind 판별 ----------
function jsonKindOf(node: JsoncNode): JsonLikeKind {
  switch (node.type) {
    case 'object':
      return 'object';
    case 'array':
      return 'array';
    case 'string':
      return 'string';
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'null':
      return 'null';
    // 'property' 같은 메타 노드는 여기 오지 않게 트래버스에서 처리
    default:
      return 'null';
  }
}

// ---------- 문자열 contentLoc 계산 ----------
function stringContentRange(text: string, valueRange: Range): Range | undefined {
  const start = valueRange.offset;
  const end = valueRange.offset + valueRange.length;
  const open = text[start];
  const close = text[end - 1];
  if ((open === '"' && close === '"') || (open === "'" && close === "'")) {
    const innerOffset = start + 1;
    const innerLen = Math.max(0, end - 1 - innerOffset);
    return {
      start: { line: valueRange.start.line, column: valueRange.start.column + 1 },
      end: offsetToLineCol(
        innerOffset + innerLen,
        ((): number[] => {
          throw new Error('lineStarts needed');
        })(),
      ),
      // 위 한 줄은 compile을 위해 필요하지만 실제 호출에선 교체됩니다.
      // 이 함수는 아래 build에서 lineStarts와 함께 재계산합니다.
      offset: innerOffset,
      length: innerLen,
    };
  }
  return undefined;
}

// ---------- 메인: 인덱스 빌드 ----------
export function buildJsonPathLocIndex(text: string): PathLocIndex {
  const errors: ParseError[] = [];
  const tree = parseTree(text, errors);

  if (!tree) {
    throw new Error('Invalid JSON: parse failed');
  }

  if (errors.length) {
    throw new Error(`JSON parse errors: ${errors.map((e) => e.error).join(', ')}`);
  }

  const lineStarts = buildLineStarts(text);
  const index: PathLocIndex = {};
  const stack: Array<{ node: JsoncNode; path: string }> = [{ node: tree, path: '$' }];

  while (stack.length) {
    const { node, path } = stack.pop()!;
    if (!node) continue;

    if (node.type === 'property') {
      // property 자체는 skip, key/value로 들어갈 때 path를 만든다
      const keyNode = node.children?.[0];
      const valNode = node.children?.[1];
      if (keyNode?.type === 'string' && valNode) {
        const child = childPath(path, String(keyNode.value));
        stack.push({ node: valNode, path: child });
      }
      continue;
    }

    const kind = jsonKindOf(node);
    const loc = toRange(node.offset, node.length, lineStarts);

    const entry: PathLocEntry = { kind, loc };

    if (kind === 'string' || kind === 'number' || kind === 'boolean' || kind === 'null') {
      const prim: PrimitiveLoc = { kind: kind as PrimitiveLoc['kind'], valueLoc: loc };

      if (kind === 'string') {
        // 문자열 컨텐츠 내부 범위(따옴표 제외)를 정확히 계산
        const start = node.offset;
        const end = node.offset + node.length;
        const open = text[start];
        const close = text[end - 1];
        if ((open === '"' && close === '"') || (open === "'" && close === "'")) {
          const innerOffset = start + 1;
          const innerLen = Math.max(0, end - 1 - innerOffset);
          prim.contentLoc = toRange(innerOffset, innerLen, lineStarts);
        }
      }

      entry.primitive = prim;
    }

    index[path] = entry;

    // 자식 순회
    if (node.type === 'object' && node.children) {
      for (let i = node.children.length - 1; i >= 0; i -= 1) {
        const prop = node.children[i];
        const keyNode = prop.children?.[0];
        const valueNode = prop.children?.[1];

        if (keyNode?.type === 'string' && valueNode) {
          const p = childPath(path, String(keyNode.value));
          stack.push({ node: valueNode, path: p });
        }
      }
    } else if (node.type === 'array' && node.children) {
      for (let i = node.children.length - 1; i >= 0; i -= 1) {
        const valueNode = node.children[i];
        const p = childPath(path, i);
        stack.push({ node: valueNode, path: p });
      }
    }
  }

  return index;
}
